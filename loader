local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "Σ⁠ - Solstice",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Solstice",
   LoadingSubtitle = "by MagmeEx",
   ShowText = "Sols", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Amethyst", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "K", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "SolsConf"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Sols Key",
      Subtitle = "Key System",
      Note = "Key = bit.ly/40bstrD", -- Use this to tell the user how to get a key
      FileName = "SolsKey", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"KEY-SOLS-74389042","Devkey79"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})
local Tab = Window:CreateTab("Main", 4483362458) -- Title, Image
local Button = Tab:CreateButton({
   Name = "Esp",
   Callback = function()
   local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

ESP = ESP or {
    Enabled = true,
    ShowBoxes = true,
    ShowNames = true,
    ShowTracers = true,
    ShowHealth = true,
    Color = nil,
    HealthColorMode = "match",
    HealthColorFunction = function(healthPercent)
        if healthPercent > 0.7 then
            return Color3.fromRGB(0, 255, 0)
        elseif healthPercent > 0.3 then
            return Color3.fromRGB(255, 165, 0)
        else
            return Color3.fromRGB(255, 0, 0)
        end
    end
}

local ESPObjects = {}

local function newDrawing(type, props)
    local obj = Drawing.new(type)
    for k, v in pairs(props) do
        obj[k] = v
    end
    return obj
end

local function createESPElements()
    return {
        Box = newDrawing("Square", {Visible = false, Thickness = 2, Filled = false, Color = Color3.new(1,1,1)}),
        Name = newDrawing("Text", {Visible = false, Center = true, Outline = true, Size = 16, Font = 2, Color = Color3.new(1,1,1)}),
        Tracer = newDrawing("Line", {Visible = false, Thickness = 1, Color = Color3.new(1,1,1)}),
        HealthBar = newDrawing("Line", {Visible = false, Thickness = 4, Color = Color3.new(0,1,0)})
    }
end

local function getRainbowColor(t)
    local freq = 2
    return Color3.new(
        math.sin(freq * t) * 0.5 + 0.5,
        math.sin(freq * t + 2) * 0.5 + 0.5,
        math.sin(freq * t + 4) * 0.5 + 0.5
    )
end

local function getBoxScreenPoints(cframe, size)
    local half = size / 2
    local points = {}
    local visible = true
    for x = -1,1,2 do
        for y = -1,1,2 do
            for z = -1,1,2 do
                local corner = cframe * Vector3.new(half.X*x, half.Y*y, half.Z*z)
                local screenPos, onScreen = Camera:WorldToViewportPoint(corner)
                if not onScreen then visible = false end
                table.insert(points, Vector2.new(screenPos.X, screenPos.Y))
            end
        end
    end
    return points, visible
end

local function hideAll(data)
    data.Box.Visible = false
    data.Name.Visible = false
    data.Tracer.Visible = false
    data.HealthBar.Visible = false
end

RunService.RenderStepped:Connect(function()
    if not ESP.Enabled then
        for _, data in pairs(ESPObjects) do
            hideAll(data)
        end
        return
    end

    local now = tick()
    local baseColor = ESP.Color or getRainbowColor(now)
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")
            if character and humanoid and humanoid.Health > 0 then
                local success, cframe, size = pcall(character.GetBoundingBox, character)
                if success and cframe and size then
                    local points, visible = getBoxScreenPoints(cframe, size)
                    if not visible then
                        if ESPObjects[player] then
                            hideAll(ESPObjects[player])
                        end
                    else
                        local data = ESPObjects[player] or createESPElements()
                        ESPObjects[player] = data

                        local minX, minY, maxX, maxY = math.huge, math.huge, -math.huge, -math.huge
                        for _, pt in ipairs(points) do
                            minX = math.min(minX, pt.X)
                            minY = math.min(minY, pt.Y)
                            maxX = math.max(maxX, pt.X)
                            maxY = math.max(maxY, pt.Y)
                        end

                        local boxWidth, boxHeight = maxX - minX, maxY - minY
                        local slimWidth = boxWidth * 0.7
                        local slimX = minX + (boxWidth - slimWidth) / 2
                        local healthRatio = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)

                        if ESP.ShowBoxes then
                            data.Box.Visible = true
                            data.Box.Position = Vector2.new(slimX, minY)
                            data.Box.Size = Vector2.new(slimWidth, boxHeight)
                            data.Box.Color = baseColor
                        else
                            data.Box.Visible = false
                        end

                        if ESP.ShowNames then
                            data.Name.Visible = true
                            data.Name.Text = player.Name
                            data.Name.Position = Vector2.new(slimX + slimWidth/2, minY - 20)
                            data.Name.Color = baseColor
                        else
                            data.Name.Visible = false
                        end

                        if ESP.ShowTracers then
                            data.Tracer.Visible = true
                            data.Tracer.From = screenCenter
                            data.Tracer.To = Vector2.new(slimX + slimWidth/2, maxY)
                            data.Tracer.Color = baseColor
                        else
                            data.Tracer.Visible = false
                        end

                        if ESP.ShowHealth then
                            local barHeight = boxHeight * healthRatio
                            data.HealthBar.Visible = true

                            if ESP.HealthColorMode == "custom" and ESP.HealthColorFunction then
                                data.HealthBar.Color = ESP.HealthColorFunction(healthRatio)
                            else
                                data.HealthBar.Color = baseColor
                            end

                            data.HealthBar.From = Vector2.new(slimX - 6, maxY)
                            data.HealthBar.To = Vector2.new(slimX - 6, maxY - barHeight)
                        else
                            data.HealthBar.Visible = false
                        end
                    end
                end
            else
                if ESPObjects[player] then
                    hideAll(ESPObjects[player])
                end
            end
        end
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            obj:Remove()
        end
        ESPObjects[player] = nil
    end
end)
   end,
})
local Button = Tab:CreateButton({
   Name = "Aimbot",
   Callback = function()
   local teamCheck = false
local fov = 90
local smoothing = 0.02
local predictionFactor = 0.08  -- Adjust this factor to improve prediction accuracy
local highlightEnabled = false  -- Variable to enable or disable target highlighting. Change to False if using an ESP script.
local lockPart = "HumanoidRootPart"  -- Choose what part it locks onto. Ex. HumanoidRootPart or Head

local Toggle = false  -- Enable or disable toggle mode
local ToggleKey = Enum.KeyCode.E  -- Choose the key for toggling aimbot lock

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")

StarterGui:SetCore("SendNotification", {
    Title = "Universal Aimbot";
    Text = "made by bran-bon";
    Duration = 5;
})

local FOVring = Drawing.new("Circle")
FOVring.Visible = true
FOVring.Thickness = 1
FOVring.Radius = fov
FOVring.Transparency = 0.8
FOVring.Color = Color3.fromRGB(255, 128, 128)
FOVring.Position = workspace.CurrentCamera.ViewportSize / 2

local currentTarget = nil
local aimbotEnabled = true
local toggleState = false  -- Variable to keep track of toggle state
local debounce = false  -- Debounce variable

local function getClosest(cframe)
    local ray = Ray.new(cframe.Position, cframe.LookVector).Unit
    local target = nil
    local mag = math.huge
    local screenCenter = workspace.CurrentCamera.ViewportSize / 2

    for i, v in pairs(Players:GetPlayers()) do
        if v.Character and v.Character:FindFirstChild(lockPart) and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v ~= Players.LocalPlayer and (v.Team ~= Players.LocalPlayer.Team or (not teamCheck)) then
            local screenPoint, onScreen = workspace.CurrentCamera:WorldToViewportPoint(v.Character[lockPart].Position)
            local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude

            if onScreen and distanceFromCenter <= fov then
                local magBuf = (v.Character[lockPart].Position - ray:ClosestPoint(v.Character[lockPart].Position)).Magnitude

                if magBuf < mag then
                    mag = magBuf
                    target = v
                end
            end
        end
    end

    return target
end

local function updateFOVRing()
    FOVring.Position = workspace.CurrentCamera.ViewportSize / 2
end

local function highlightTarget(target)
    if highlightEnabled and target and target.Character then
        local highlight = Instance.new("Highlight")
        highlight.Adornee = target.Character
        highlight.FillColor = Color3.fromRGB(255, 128, 128)
        highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
        highlight.Parent = target.Character
    end
end

local function removeHighlight(target)
    if highlightEnabled and target and target.Character and target.Character:FindFirstChildOfClass("Highlight") then
        target.Character:FindFirstChildOfClass("Highlight"):Destroy()
    end
end

local function predictPosition(target)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local velocity = target.Character.HumanoidRootPart.Velocity
        local position = target.Character[lockPart].Position
        local predictedPosition = position + (velocity * predictionFactor)
        return predictedPosition
    end
    return nil
end

local function handleToggle()
    if debounce then return end
    debounce = true
    toggleState = not toggleState
    wait(0.3)  -- Debounce time to prevent multiple toggles
    debounce = false
end

loop = RunService.RenderStepped:Connect(function()
    if aimbotEnabled then
        updateFOVRing()

        local localPlayer = Players.LocalPlayer.Character
        local cam = workspace.CurrentCamera
        local screenCenter = workspace.CurrentCamera.ViewportSize / 2

        if Toggle then
            if UserInputService:IsKeyDown(ToggleKey) then
                handleToggle()
            end
        else
            toggleState = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
        end

        if toggleState then
            if not currentTarget then
                currentTarget = getClosest(cam.CFrame)
                highlightTarget(currentTarget)  -- Highlight the new target if enabled
            end

            if currentTarget and currentTarget.Character and currentTarget.Character:FindFirstChild(lockPart) then
                local predictedPosition = predictPosition(currentTarget)
                if predictedPosition then
                    workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(cam.CFrame.Position, predictedPosition), smoothing)
                end
                FOVring.Color = Color3.fromRGB(0, 255, 0)  -- Change FOV ring color to green when locked onto a target
            else
                FOVring.Color = Color3.fromRGB(255, 128, 128)  -- Revert FOV ring color to original when not locked onto a target
            end
        else
            if currentTarget and highlightEnabled then
                removeHighlight(currentTarget)  -- Remove highlight from the old target
            end
            currentTarget = nil
            FOVring.Color = Color3.fromRGB(255, 128, 128)  -- Revert FOV ring color to original when not locked onto a target
        end
    end
end)
end})
local Button = Tab:CreateButton({
   Name = "Virtual Keyboard",
   Callback = function()
   local function ClonedService(name)
    local Service = (game.GetService);
	local Reference = (cloneref) or function(reference) return reference end
	return Reference(Service(game, name));
end

local UIS = ClonedService("UserInputService")
local GuiS = ClonedService("GuiService")
local VIM = ClonedService("VirtualInputManager")
local TS = ClonedService("TextService")

local function protectUI(sGui)
    if sGui:IsA("ScreenGui") then
        sGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
		sGui.DisplayOrder = 999999999
		sGui.ResetOnSpawn = false
		sGui.IgnoreGuiInset = true
    end
    local cGUI = ClonedService("CoreGui")
    local lPlr = ClonedService("Players").LocalPlayer

    local function NAProtection(inst, var)
        if inst then
            if var then
                inst[var] = "\0"
                inst.Archivable = false
            else
                inst.Name = "\0"
                inst.Archivable = false
            end
        end
    end

    if gethui then
		NAProtection(sGui)
		sGui.Parent = gethui()
		return sGui
	elseif cGUI and cGUI:FindFirstChild("RobloxGui") then
		NAProtection(sGui)
		sGui.Parent = cGUI:FindFirstChild("RobloxGui")
		return sGui
	elseif cGUI then
		NAProtection(sGui)
		sGui.Parent = cGUI
		return sGui
	elseif lPlr and lPlr:FindFirstChildWhichIsA("PlayerGui") then
		NAProtection(sGui)
		sGui.Parent = lPlr:FindFirstChildWhichIsA("PlayerGui")
		sGui.ResetOnSpawn = false
		return sGui
	else
		return nil
	end
end

local themes = {
	Dark = {Bg = Color3.fromRGB(40, 40, 40), Btn = Color3.fromRGB(60, 60, 60), Acc = Color3.fromRGB(60, 180, 60), Txt = Color3.fromRGB(255, 255, 255)},
	Light = {Bg = Color3.fromRGB(245, 245, 245), Btn = Color3.fromRGB(220, 220, 220), Acc = Color3.fromRGB(100, 200, 255), Txt = Color3.fromRGB(0, 0, 0)},

	Red = {Bg = Color3.fromRGB(60, 0, 0), Btn = Color3.fromRGB(100, 0, 0), Acc = Color3.fromRGB(200, 30, 30), Txt = Color3.fromRGB(255, 255, 255)},
	Green = {Bg = Color3.fromRGB(0, 60, 0), Btn = Color3.fromRGB(0, 100, 0), Acc = Color3.fromRGB(50, 200, 50), Txt = Color3.fromRGB(255, 255, 255)},
	Blue = {Bg = Color3.fromRGB(0, 0, 60), Btn = Color3.fromRGB(0, 0, 100), Acc = Color3.fromRGB(50, 100, 255), Txt = Color3.fromRGB(255, 255, 255)},
	Yellow = {Bg = Color3.fromRGB(100, 100, 0), Btn = Color3.fromRGB(180, 180, 0), Acc = Color3.fromRGB(255, 255, 50), Txt = Color3.fromRGB(0, 0, 0)},
	Orange = {Bg = Color3.fromRGB(100, 50, 0), Btn = Color3.fromRGB(160, 80, 0), Acc = Color3.fromRGB(255, 140, 0), Txt = Color3.fromRGB(255, 255, 255)},
	Purple = {Bg = Color3.fromRGB(50, 0, 100), Btn = Color3.fromRGB(80, 0, 160), Acc = Color3.fromRGB(180, 50, 255), Txt = Color3.fromRGB(255, 255, 255)},
	Pink = {Bg = Color3.fromRGB(100, 0, 60), Btn = Color3.fromRGB(180, 0, 100), Acc = Color3.fromRGB(255, 105, 180), Txt = Color3.fromRGB(255, 255, 255)},
	Teal = {Bg = Color3.fromRGB(0, 60, 60), Btn = Color3.fromRGB(0, 100, 100), Acc = Color3.fromRGB(0, 200, 200), Txt = Color3.fromRGB(255, 255, 255)},
	Cyan = {Bg = Color3.fromRGB(0, 100, 100), Btn = Color3.fromRGB(0, 150, 150), Acc = Color3.fromRGB(0, 255, 255), Txt = Color3.fromRGB(0, 0, 0)},
	Indigo = {Bg = Color3.fromRGB(40, 0, 80), Btn = Color3.fromRGB(60, 0, 120), Acc = Color3.fromRGB(90, 70, 255), Txt = Color3.fromRGB(255, 255, 255)},
	Lime = {Bg = Color3.fromRGB(80, 100, 0), Btn = Color3.fromRGB(120, 180, 0), Acc = Color3.fromRGB(180, 255, 0), Txt = Color3.fromRGB(0, 0, 0)},
	Magenta = {Bg = Color3.fromRGB(80, 0, 80), Btn = Color3.fromRGB(140, 0, 140), Acc = Color3.fromRGB(255, 0, 255), Txt = Color3.fromRGB(255, 255, 255)},
	Maroon = {Bg = Color3.fromRGB(80, 0, 0), Btn = Color3.fromRGB(120, 0, 0), Acc = Color3.fromRGB(180, 20, 20), Txt = Color3.fromRGB(255, 255, 255)},
	Navy = {Bg = Color3.fromRGB(0, 0, 60), Btn = Color3.fromRGB(0, 0, 100), Acc = Color3.fromRGB(0, 0, 180), Txt = Color3.fromRGB(255, 255, 255)},
	Olive = {Bg = Color3.fromRGB(80, 80, 0), Btn = Color3.fromRGB(100, 100, 20), Acc = Color3.fromRGB(160, 160, 60), Txt = Color3.fromRGB(0, 0, 0)},
	Brown = {Bg = Color3.fromRGB(60, 30, 0), Btn = Color3.fromRGB(100, 50, 0), Acc = Color3.fromRGB(160, 80, 20), Txt = Color3.fromRGB(255, 255, 255)},
	Silver = {Bg = Color3.fromRGB(200, 200, 200), Btn = Color3.fromRGB(230, 230, 230), Acc = Color3.fromRGB(255, 255, 255), Txt = Color3.fromRGB(0, 0, 0)}
}

local gui = Instance.new("ScreenGui")
gui.Name = "VKB"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
protectUI(gui)

local Main = Instance.new("Frame")
Main.Name = "Main"
Main.Size = UDim2.new(0, 650, 0, 250)
Main.Position = UDim2.new(0.5, -325, 0.8, -125)
Main.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Main.BorderSizePixel = 0
Main.Parent = gui

local c1 = Instance.new("UICorner")
c1.CornerRadius = UDim.new(0, 10)
c1.Parent = Main

local Title = Instance.new("Frame")
Title.Name = "Title"
Title.Size = UDim2.new(1, 0, 0, 30)
Title.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
Title.BorderSizePixel = 0
Title.Parent = Main

local c2 = Instance.new("UICorner")
c2.CornerRadius = UDim.new(0, 10)
c2.Parent = Title

local TLabel = Instance.new("TextLabel")
TLabel.Size = UDim2.new(1, -200, 1, 0)
TLabel.Position = UDim2.new(0, 10, 0, 0)
TLabel.BackgroundTransparency = 1
TLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TLabel.TextSize = 16
TLabel.Font = Enum.Font.SourceSansBold
TLabel.Text = "Virtual Keyboard"
TLabel.TextXAlignment = Enum.TextXAlignment.Left
TLabel.Parent = Title

local Close = Instance.new("TextButton")
Close.Name = "Close"
Close.Size = UDim2.new(0, 40, 0, 25)
Close.Position = UDim2.new(1, -85, 0, 2.5)
Close.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
Close.TextColor3 = Color3.fromRGB(255, 255, 255)
Close.Text = "X"
Close.TextSize = 16
Close.Font = Enum.Font.SourceSansBold
Close.Parent = Title
local c3 = Instance.new("UICorner")
c3.CornerRadius = UDim.new(0, 5)
c3.Parent = Close

local AddBTN = Instance.new("TextButton")
AddBTN.Name = "Add"
AddBTN.Size = UDim2.new(0, 40, 0, 25)
AddBTN.Position = UDim2.new(1, -45, 0, 2.5)
AddBTN.BackgroundColor3 = Color3.fromRGB(60, 180, 60)
AddBTN.TextColor3 = Color3.fromRGB(255, 255, 255)
AddBTN.Text = "+"
AddBTN.TextSize = 16
AddBTN.Font = Enum.Font.SourceSansBold
AddBTN.Parent = Title
local c4 = Instance.new("UICorner")
c4.CornerRadius = UDim.new(0, 5)
c4.Parent = AddBTN

local ThemeBtn = Instance.new("TextButton")
ThemeBtn.Name = "Theme"
ThemeBtn.Size = UDim2.new(0, 80, 0, 25)
ThemeBtn.Position = UDim2.new(1, -170, 0, 2.5)
ThemeBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
ThemeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
ThemeBtn.Text = "Dark"
ThemeBtn.TextSize = 14
ThemeBtn.Font = Enum.Font.SourceSansBold
ThemeBtn.Parent = Title
local c5 = Instance.new("UICorner")
c5.CornerRadius = UDim.new(0, 5)
c5.Parent = ThemeBtn

local Keys = Instance.new("Frame")
Keys.Name = "Keys"
Keys.Size = UDim2.new(1, -20, 1, -40)
Keys.Position = UDim2.new(0, 10, 0, 35)
Keys.BackgroundTransparency = 1
Keys.Parent = Main

local Toggle = Instance.new("TextButton")
Toggle.Name = "Toggle"
Toggle.Size = UDim2.new(0, 50, 0, 50)
Toggle.Position = UDim2.new(0, 20, 0.5, -25)
Toggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
Toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
Toggle.Text = "⌨️"
Toggle.TextSize = 20
Toggle.Font = Enum.Font.SourceSansBold
Toggle.Parent = gui
local c6 = Instance.new("UICorner")
c6.CornerRadius = UDim.new(0, 10)
c6.Parent = Toggle

local function applyTheme(name)
	local t = themes[name]
	if not t then return end
	Main.BackgroundColor3 = t.Bg
	Title.BackgroundColor3 = t.Btn
	Keys.BackgroundColor3 = t.Bg
	Toggle.BackgroundColor3 = t.Btn
	AddBTN.BackgroundColor3 = isSel and t.Acc or t.Btn
	Close.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	ThemeBtn.BackgroundColor3 = t.Btn
	TLabel.TextColor3 = t.Txt
	AddBTN.TextColor3 = t.Txt
	Close.TextColor3 = t.Txt
	Toggle.TextColor3 = t.Txt
	ThemeBtn.TextColor3 = t.Txt
	for _, k in ipairs(Keys:GetChildren()) do
		if k:IsA("TextButton") then
			k.BackgroundColor3 = t.Btn
			k.TextColor3 = t.Txt
		end
	end
end

ThemeBtn.MouseButton1Click:Connect(function()
	local opts = {
		"Dark", "Light", "Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink",
		"Teal", "Cyan", "Indigo", "Lime", "Magenta", "Maroon", "Navy", "Olive", "Brown", "Silver"
	}
	local idx = table.find(opts, ThemeBtn.Text) or 1
	local next = opts[idx % #opts + 1]
	ThemeBtn.Text = next
	applyTheme(next)
end)

applyTheme("Dark")

local keyboardLayout = {
    {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "Backspace"},
    {"Tab", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "[", "]", "\\"},
    {"Caps", "A", "S", "D", "F", "G", "H", "J", "K", "L", ";", "'", "Enter"},
    {"Shift", "Z", "X", "C", "V", "B", "N", "M", ",", ".", "/", "Shift"},
    {"Ctrl", "Win", "Alt", "Space", "Alt", "Fn", "Ctrl"}
}

local keyToEnum = {
    ["1"] = Enum.KeyCode.One,
    ["2"] = Enum.KeyCode.Two,
    ["3"] = Enum.KeyCode.Three,
    ["4"] = Enum.KeyCode.Four,
    ["5"] = Enum.KeyCode.Five,
    ["6"] = Enum.KeyCode.Six,
    ["7"] = Enum.KeyCode.Seven,
    ["8"] = Enum.KeyCode.Eight,
    ["9"] = Enum.KeyCode.Nine,
    ["0"] = Enum.KeyCode.Zero,
    ["-"] = Enum.KeyCode.Minus,
    ["="] = Enum.KeyCode.Equals,
    ["Backspace"] = Enum.KeyCode.Backspace,
    ["Tab"] = Enum.KeyCode.Tab,
    ["Q"] = Enum.KeyCode.Q,
    ["W"] = Enum.KeyCode.W,
    ["E"] = Enum.KeyCode.E,
    ["R"] = Enum.KeyCode.R,
    ["T"] = Enum.KeyCode.T,
    ["Y"] = Enum.KeyCode.Y,
    ["U"] = Enum.KeyCode.U,
    ["I"] = Enum.KeyCode.I,
    ["O"] = Enum.KeyCode.O,
    ["P"] = Enum.KeyCode.P,
    ["["] = Enum.KeyCode.LeftBracket,
    ["]"] = Enum.KeyCode.RightBracket,
    ["\\"] = Enum.KeyCode.BackSlash,
    ["Caps"] = Enum.KeyCode.CapsLock,
    ["A"] = Enum.KeyCode.A,
    ["S"] = Enum.KeyCode.S,
    ["D"] = Enum.KeyCode.D,
    ["F"] = Enum.KeyCode.F,
    ["G"] = Enum.KeyCode.G,
    ["H"] = Enum.KeyCode.H,
    ["J"] = Enum.KeyCode.J,
    ["K"] = Enum.KeyCode.K,
    ["L"] = Enum.KeyCode.L,
    [";"] = Enum.KeyCode.Semicolon,
    ["'"] = Enum.KeyCode.Quote,
    ["Enter"] = Enum.KeyCode.Return,
    ["Shift"] = Enum.KeyCode.LeftShift,
    ["Z"] = Enum.KeyCode.Z,
    ["X"] = Enum.KeyCode.X,
    ["C"] = Enum.KeyCode.C,
    ["V"] = Enum.KeyCode.V,
    ["B"] = Enum.KeyCode.B,
    ["N"] = Enum.KeyCode.N,
    ["M"] = Enum.KeyCode.M,
    [","] = Enum.KeyCode.Comma,
    ["."] = Enum.KeyCode.Period,
    ["/"] = Enum.KeyCode.Slash,
    ["Ctrl"] = Enum.KeyCode.LeftControl,
    ["Win"] = Enum.KeyCode.LeftMeta,
    ["Alt"] = Enum.KeyCode.LeftAlt,
    ["Space"] = Enum.KeyCode.Space,
    ["Fn"] = Enum.KeyCode.F1
}

local specialKeySizes = {
    ["Backspace"] = 2,
    ["Tab"] = 1.5,
    ["Caps"] = 1.75,
    ["Enter"] = 1.75,
    ["Shift"] = 2.25,
    ["Ctrl"] = 1.5,
    ["Win"] = 1.25,
    ["Alt"] = 1.25,
    ["Space"] = 6,
    ["Fn"] = 1.25
}

local function createKey(text, row, col, width)
    local key = Instance.new("TextButton")
    key.Name = "Key_"..text
    key.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    key.BorderSizePixel = 0
    key.TextColor3 = Color3.fromRGB(255, 255, 255)
    key.Text = text
    key.TextSize = 16
    key.Font = Enum.Font.SourceSans
    key.AutoButtonColor = true

    local keyCorner = Instance.new("UICorner")
    keyCorner.CornerRadius = UDim.new(0, 5)
    keyCorner.Parent = key

    local isHolding = false
    local keyCode = keyToEnum[text]

    key.MouseButton1Down:Connect(function()
        key.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        isHolding = true

        if keyCode then
            VIM:SendKeyEvent(true, keyCode, false, game)
        end
    end)

    key.MouseButton1Up:Connect(function()
        key.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        isHolding = false

        if keyCode then
            VIM:SendKeyEvent(false, keyCode, false, game)
        end
    end)

    key.MouseLeave:Connect(function()
        if isHolding and keyCode then
            VIM:SendKeyEvent(false, keyCode, false, game)
            isHolding = false
            key.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end
    end)

    return key
end

local rowHeight = 1 / #keyboardLayout
local currentY = 0

for rowIndex, row in ipairs(keyboardLayout) do
    local totalWidth = 0
    for _, key in ipairs(row) do
        totalWidth = totalWidth + (specialKeySizes[key] or 1)
    end

    local currentX = 0
    for keyIndex, keyText in ipairs(row) do
        local keyWidth = specialKeySizes[keyText] or 1
        local relativeWidth = keyWidth / totalWidth

        local key = createKey(keyText, rowIndex, keyIndex, keyWidth)
        key.Size = UDim2.new(relativeWidth, -2, rowHeight, -2)
        key.Position = UDim2.new(currentX, 1, currentY, 1)
        key.Parent = Keys

        currentX = currentX + relativeWidth
    end

    currentY = currentY + rowHeight
end

local function makeDraggable(frame, handle)
    local isDragging = false
    local dragInput
    local dragStart
    local startPos

    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStart = input.Position
            startPos = frame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    isDragging = false
                end
            end)
        end
    end)

    handle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UIS.InputChanged:Connect(function(input)
        if input == dragInput and isDragging then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

makeDraggable(Main, Title)
makeDraggable(Toggle, Toggle)

local isSelectionMode = false

AddBTN.MouseButton1Click:Connect(function()
    isSelectionMode = not isSelectionMode
    AddBTN.BackgroundColor3 = isSelectionMode and Color3.fromRGB(180, 60, 60) or Color3.fromRGB(60, 180, 60)
end)

local function createFloatingKey(text)
	local sz = TS:GetTextSize(text, 20, Enum.Font.SourceSansBold, Vector2.new(math.huge, math.huge))

	local btn = Instance.new("TextButton")
	btn.Name = "FloatingKey_" .. text
	btn.Size = UDim2.new(0, sz.X + 20, 0, sz.Y + 20)
	btn.Position = UDim2.new(0.5, -((sz.X + 20) / 2), 0.5, -((sz.Y + 20) / 2))
	btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	btn.TextColor3 = Color3.fromRGB(255, 255, 255)
	btn.Text = text
	btn.TextSize = 20
	btn.Font = Enum.Font.SourceSansBold
	btn.Parent = gui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = btn

	local remove = Instance.new("TextButton")
	remove.Name = "Remove"
	remove.Size = UDim2.new(0, 20, 0, 20)
	remove.Position = UDim2.new(1, -25, 0, -5)
	remove.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	remove.Text = "X"
	remove.TextColor3 = Color3.fromRGB(255, 255, 255)
	remove.TextSize = 16
	remove.Font = Enum.Font.SourceSansBold
	remove.Parent = btn

	local rCorner = Instance.new("UICorner")
	rCorner.CornerRadius = UDim.new(0, 10)
	rCorner.Parent = remove

	local isDown = false
	local keyCode = keyToEnum[text]

	btn.MouseButton1Down:Connect(function()
		btn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
		isDown = true
		if keyCode then VIM:SendKeyEvent(true, keyCode, false, game) end
	end)

	btn.MouseButton1Up:Connect(function()
		btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		isDown = false
		if keyCode then VIM:SendKeyEvent(false, keyCode, false, game) end
	end)

	btn.MouseLeave:Connect(function()
		if isDown and keyCode then
			VIM:SendKeyEvent(false, keyCode, false, game)
			btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
			isDown = false
		end
	end)

	remove.MouseButton1Click:Connect(function()
		btn:Destroy()
	end)

	makeDraggable(btn, btn)
end

for _, key in ipairs(Keys:GetChildren()) do
    if key:IsA("TextButton") then
        key.MouseButton1Click:Connect(function()
            if isSelectionMode then
                createFloatingKey(key.Text)
                isSelectionMode = false
                AddBTN.BackgroundColor3 = Color3.fromRGB(60, 180, 60)
            end
        end)
    end
end

Close.MouseButton1Click:Connect(function()
    gui:Destroy()
end)

Toggle.MouseButton1Click:Connect(function()
    Main.Visible = not Main.Visible
    Toggle.BackgroundColor3 = Main.Visible and Color3.fromRGB(80, 180, 80) or Color3.fromRGB(60, 60, 60)
end)

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.F2 then
        Main.Visible = not Main.Visible
        Toggle.BackgroundColor3 = Main.Visible and Color3.fromRGB(80, 180, 80) or Color3.fromRGB(60, 60, 60)
    end
end)
